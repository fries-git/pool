<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pool — cleaner client</title>
<style>
:root{
  --bg:#0c1113;
  --panel:#0f1315;
  --muted:#9aa0a6;
  --accent:#2a9df4;
  --accent-2:#1fb06f;
  --glass: rgba(255,255,255,0.03);
  --glass-2: rgba(255,255,255,0.02);
  --card-shadow: 0 10px 30px rgba(0,0,0,0.6);
  --radius:12px;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:#e8eef2;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
.header{display:flex;gap:12px;align-items:center;padding:14px;max-width:1200px;margin:0 auto}
.brand{font-weight:700;letter-spacing:0.6px}
.controls{display:flex;gap:8px;align-items:center;margin-left:auto}
input,button,select{background:var(--panel);border:1px solid rgba(255,255,255,0.03);padding:8px 10px;border-radius:10px;color:inherit;outline:none}
input::placeholder{color:var(--muted)}
.button{background:linear-gradient(180deg,var(--accent),#177fc1);border:none;padding:9px 12px;border-radius:10px;cursor:pointer;color:#fff;box-shadow:0 6px 18px rgba(42,157,244,0.14);transition:transform .12s ease}
.button:active{transform:translateY(1px)}
.container{max-width:1200px;margin:18px auto;display:flex;gap:18px;padding:12px}
.table-wrap{flex:1;display:flex;flex-direction:column;gap:10px;align-items:center}
canvas{border-radius:14px;box-shadow:var(--card-shadow);background:transparent;display:block;max-width:100%;height:auto}
.side{width:340px;background:linear-gradient(180deg,var(--panel),#0d1112);border-radius:12px;padding:12px;box-shadow:var(--card-shadow);display:flex;flex-direction:column;gap:10px}
.section-title{font-size:13px;color:var(--muted);display:flex;justify-content:space-between;align-items:center}
.small{font-size:13px;color:var(--muted)}
.server-list{display:flex;flex-direction:column;gap:8px;max-height:160px;overflow:auto;padding-right:6px}
.server-item{display:flex;justify-content:space-between;align-items:center;padding:8px;background:var(--glass);border-radius:8px}
.players-list{display:flex;flex-direction:column;gap:6px}
.player{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:var(--glass-2)}
.player.current{color:var(--accent);font-weight:700;border:1px solid rgba(42,157,244,0.08)}
.pocket-grid{display:flex;flex-wrap:wrap;gap:8px}
.pocket-swatch{width:34px;height:34px;border-radius:999px;display:inline-flex;align-items:center;justify-content:center;font-size:11px;position:relative;border:2px solid rgba(0,0,0,0.35);box-shadow:inset 0 -2px 6px rgba(0,0,0,0.4)}
.pocket-swatch .inner{width:18px;height:18px;border-radius:50%}
.chat{display:flex;flex-direction:column;gap:8px}
#chatbox{height:120px;overflow:auto;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);padding:8px;border-radius:8px}
.notice{padding:8px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);font-size:13px}
.small-btn{padding:6px 8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03);cursor:pointer}
.pulse { animation: pulse-pocket 680ms ease-out; }
@keyframes pulse-pocket {
  0% { transform: scale(0.85); box-shadow:0 0 0 0 rgba(255,255,255,0.12); }
  60% { transform: scale(1.06); box-shadow:0 10px 30px rgba(0,0,0,0.5); }
  100% { transform: scale(1); box-shadow:none; }
}

/* responsive */
@media (max-width:980px){ .container{flex-direction:column;padding:8px} .side{width:100%} .header{padding:10px} }
</style>
</head>
<body>
  <div class="header">
    <div class="brand">Pool — Cleaner UI</div>
    <div class="small" style="margin-left:10px;color:var(--muted)">multiplayer 8-ball demo</div>
    <div class="controls">
      <input id="username" placeholder="username" />
      <button id="create" class="button">Create</button>
      <input id="room" placeholder="ROOM" style="text-transform:uppercase; width:86px"/>
      <button id="join" class="button">Join</button>
      <div id="status" class="small" style="margin-left:10px">disconnected</div>
    </div>
  </div>

  <div class="container">
    <div class="table-wrap">
      <canvas id="table" width="800" height="400" aria-label="Pool table"></canvas>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="small" id="notice">Not in a room</div>
        <div style="flex:1"></div>
        <button id="refreshRooms" class="small-btn">Refresh</button>
      </div>
    </div>

    <aside class="side" aria-label="Side panel">
      <div>
        <div class="section-title"><div><strong>Servers</strong></div><div class="small">active rooms</div></div>
        <div id="serverBrowser" class="server-list small"></div>
      </div>

      <div>
        <div class="section-title"><div><strong>Players</strong></div><div class="small">turn & groups</div></div>
        <div id="players" class="players-list small"></div>
      </div>

      <div>
        <div class="section-title"><div><strong>Pocketed</strong></div><div class="small">recent</div></div>
        <div id="pocketed" class="pocket-grid small"></div>
      </div>

      <div class="chat">
        <div class="section-title"><div><strong>Chat</strong></div><div class="small">local</div></div>
        <div id="chatbox"></div>
        <div style="display:flex;gap:8px">
          <input id="chat" placeholder="say something" style="flex:1" />
          <button id="sendChat" class="small-btn">Send</button>
        </div>
      </div>
    </aside>
  </div>

<script>
/* ======= Client logic (cleaner + interpolation + animated stripes) ======= */
const canvas = document.getElementById('table');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');
const playersEl = document.getElementById('players');
const pocketedEl = document.getElementById('pocketed');
const chatBox = document.getElementById('chatbox');
const noticeEl = document.getElementById('notice');
const serverBrowser = document.getElementById('serverBrowser');

let ws = null, myId = null;
let lastServerState = null, prevServerState = null;
let lastStateRecv = 0;
let dragging = null;
const SHOOT_SCALE = 90;
const POCKET_RADIUS = 28;
const PALETTE = {1:'#FFD400',2:'#0047AB',3:'#C41E3A',4:'#6A0DAD',5:'#FF8C00',6:'#006400',7:'#6F1D1B',8:'#000000',9:'#FFD400',10:'#0047AB',11:'#C41E3A',12:'#6A0DAD',13:'#FF8C00',14:'#006400',15:'#6F1D1B'};

function setStatus(s){ statusEl.textContent = s; }
function connect(){
  if(ws && (ws.readyState===1||ws.readyState===0)) return;
  const proto = (location.protocol==='https:') ? 'wss' : 'ws';
  ws = new WebSocket(proto + '://' + location.host);
  ws.onopen = ()=> setStatus('connected');
  ws.onclose = ()=> { setStatus('disconnected'); myId = null; };
  ws.onerror = ()=> setStatus('error');
  ws.onmessage = ev => {
    const msg = JSON.parse(ev.data);
    switch(msg.t){
      case 'joined': myId = msg.id; setStatus('in room '+msg.code); noticeEl.textContent = 'In room '+msg.code; break;
      case 'state': prevServerState = lastServerState; lastServerState = msg; lastStateRecv = Date.now(); renderPlayersAndPocketed(msg.state); handleLastEvent(msg.state); break;
      case 'chat': addChat(msg.from+': '+msg.msg); break;
      case 'assigned': addSystem('Assigned: '+msg.playerId+' → '+msg.group); break;
      case 'foul': addSystem('Foul: '+(msg.msg||'')); break;
      case 'game_over': addSystem('Game Over: '+(msg.winner||'')+' — '+(msg.reason||'')); break;
      case 'error': addSystem('Error: '+(msg.msg||'')); break;
      case 'shoot_rejected': addSystem('Shoot rejected: '+(msg.reason||'')); break;
      case 'place_rejected': addSystem('Place rejected: '+(msg.reason||'')); break;
      default: break;
    }
  };
}

/* UI wiring */
document.getElementById('create').onclick = ()=>{
  const username = (document.getElementById('username').value || 'Host').trim();
  connect();
  if(ws.readyState===1) ws.send(JSON.stringify({ t:'create', name: username }));
  else ws.addEventListener('open', ()=> ws.send(JSON.stringify({ t:'create', name: username })), { once:true });
};
document.getElementById('join').onclick = ()=>{
  const username = (document.getElementById('username').value || 'Player').trim();
  const code = (document.getElementById('room').value || '').trim().toUpperCase();
  if(!code) return;
  connect();
  if(ws.readyState===1) ws.send(JSON.stringify({ t:'join', code, name: username }));
  else ws.addEventListener('open', ()=> ws.send(JSON.stringify({ t:'join', code, name: username })), { once:true });
};
document.getElementById('sendChat').onclick = sendChat;
document.getElementById('chat').addEventListener('keydown', e=>{ if(e.key==='Enter') sendChat(); });
function sendChat(){ const el = document.getElementById('chat'); const txt = el.value.trim(); if(!txt || !ws || ws.readyState!==1) return; ws.send(JSON.stringify({ t:'chat', msg: txt })); el.value=''; }

function addChat(s){ const d=document.createElement('div'); d.textContent = s; chatBox.appendChild(d); chatBox.scrollTop = chatBox.scrollHeight; }
function addSystem(s){ const d=document.createElement('div'); d.textContent = '• ' + s; d.style.color = '#9aa0a6'; chatBox.appendChild(d); chatBox.scrollTop = chatBox.scrollHeight; }

/* server browser */
async function fetchRooms(){ try{ const r=await fetch('/rooms'); const list=await r.json(); renderServers(list); }catch(e){} }
function renderServers(list){
  serverBrowser.innerHTML = '';
  if(!list || !list.length) { serverBrowser.innerHTML = '<div class="small">No active rooms</div>'; return; }
  list.forEach(r => {
    const div = document.createElement('div'); div.className='server-item';
    div.innerHTML = `<div>${r.code} (${r.players}/2) ${r.host?'- '+r.host:''}</div><div><button class="small-btn" data-code="${r.code}">Join</button></div>`;
    div.querySelector('button').onclick = ()=>{ document.getElementById('room').value = r.code; document.getElementById('join').click(); };
    serverBrowser.appendChild(div);
  });
}
fetchRooms(); setInterval(fetchRooms, 4500);
document.getElementById('refreshRooms').onclick = fetchRooms;

/* prediction (simple raycast for visual aim) */
function predictPath(cueX, cueY, angle, power, maxLen=1400){
  const segments = [];
  let x = cueX, y = cueY;
  let vx = Math.cos(angle) * power * SHOOT_SCALE, vy = Math.sin(angle) * power * SHOOT_SCALE;
  const step = 6, maxSteps = Math.ceil(maxLen/step);
  const ballsAuth = lastServerState ? (lastServerState.state.balls||[]) : [];
  const pockets = [{x:0,y:0},{x:400,y:0},{x:800,y:0},{x:0,y:400},{x:400,y:400},{x:800,y:400}];
  let traveled = 0;
  for(let s=0;s<maxSteps;s++){
    const nx = x + vx * (step/60), ny = y + vy * (step/60);
    for(const p of pockets){ if(Math.hypot(nx-p.x, ny-p.y) <= POCKET_RADIUS + 6){ segments.push({x:nx,y:ny,pocket:true}); return segments; } }
    for(const b of ballsAuth){ if(b.id === 'cue') continue; if(Math.hypot(nx-b.x, ny-b.y) <= (b.r||10) + 2){ segments.push({x:nx,y:ny,hitBallId:b.id}); return segments; } }
    if(nx - 10 < 0){ vx = -vx; x = 10; y = ny; } else if(nx + 10 > canvas.width){ vx = -vx; x = canvas.width - 10; y = ny; } else x = nx;
    if(ny - 10 < 0){ vy = -vy; y = 10; x = nx; } else if(ny + 10 > canvas.height){ vy = -vy; y = canvas.height - 10; x = nx; } else y = ny;
    traveled += step;
    if(traveled % 80 === 0) segments.push({x,y,pocket:false});
    vx *= 0.999; vy *= 0.999;
  }
  segments.push({x,y,pocket:false});
  return segments;
}

/* input: drag to aim */
canvas.addEventListener('mousedown', e=>{
  const st = lastServerState ? lastServerState.state : null;
  if(!st) return;
  if(!st.turn || st.turn !== myId){ noticeEl.textContent='Not your turn'; setTimeout(()=>noticeEl.textContent='',900); return; }
  if(st.ballInHand){ const rect = canvas.getBoundingClientRect(); const mx = e.clientX-rect.left, my = e.clientY-rect.top; if(ws && ws.readyState===1) ws.send(JSON.stringify({ t:'place_cue', x: mx, y: my })); return; }
  const moving = (st.balls||[]).some(b => Math.hypot(b.vx||0,b.vy||0) > 0.03);
  if(moving){ noticeEl.textContent='Balls still moving'; setTimeout(()=>noticeEl.textContent='',900); return; }
  const rect = canvas.getBoundingClientRect(); const mx = e.clientX-rect.left, my = e.clientY-rect.top;
  const cue = st.balls.find(b => b.id === 'cue'); if(!cue) return;
  dragging = { cx: cue.x, cy: cue.y, mx, my, pred: [] };
  updateDraggingPrediction();
});
canvas.addEventListener('mousemove', e=>{
  if(!dragging) return;
  const rect = canvas.getBoundingClientRect();
  dragging.mx = e.clientX-rect.left; dragging.my = e.clientY-rect.top;
  updateDraggingPrediction();
});
window.addEventListener('mouseup', e=>{
  if(!dragging) return;
  const dx = dragging.cx - dragging.mx, dy = dragging.cy - dragging.my;
  const dist = Math.hypot(dx, dy), power = Math.min(1.5, dist / 180);
  const angle = Math.atan2(dy, dx) + Math.PI;
  if(ws && ws.readyState === 1) ws.send(JSON.stringify({ t:'shoot', power, angle }));
  dragging = null;
});
function updateDraggingPrediction(){
  if(!dragging) return;
  const dx = dragging.cx - dragging.mx, dy = dragging.cy - dragging.my;
  const dist = Math.hypot(dx, dy), power = Math.min(1.5, dist / 180);
  const angle = Math.atan2(dy, dx) + Math.PI;
  dragging.pred = predictPath(dragging.cx, dragging.cy, angle, );
}

/* state rendering helpers */
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function lerp(a,b,t){ return a + (b-a) * t; }
function findById(arr,id){ return (arr||[]).find(x=>x.id===id); }

/* Interpolation:
   - if we have prev & last states, interpolate balls positions by id using alpha based on elapsed time
   - expected broadcast interval ~ 50ms (server BROADCAST_RATE=20). We smooth accordingly.
*/
function interpolatedState(){
  if(!lastServerState) return null;
  const latest = lastServerState.state;
  if(!prevServerState) return latest;
  const aTime = prevServerState.serverTime || 0;
  const bTime = lastServerState.serverTime || Date.now();
  const now = Date.now();
  const expectedDt = 1000 / 20; // 50ms
  const elapsed = now - bTime;
  const alpha = clamp((now - bTime) / expectedDt, 0, 1); // extrapolate a little
  const t = clamp((now - aTime) / Math.max(1, bTime - aTime), 0, 1);
  // we'll blend mostly toward latest plus slight extrapolation using alpha
  const balls = [];
  const prevBalls = prevServerState.state.balls || [];
  const nextBalls = latest.balls || [];
  const idSet = new Set([...prevBalls.map(b=>b.id), ...nextBalls.map(b=>b.id)]);
  idSet.forEach(id=>{
    const pb = findById(prevBalls,id);
    const nb = findById(nextBalls,id);
    if(pb && nb){
      const bx = lerp(pb.x, nb.x, t);
      const by = lerp(pb.y, nb.y, t);
      const bvx = lerp(pb.vx||0, nb.vx||0, t);
      const bvy = lerp(pb.vy||0, nb.vy||0, t);
      balls.push(Object.assign({}, nb, { x: bx + (bvx * alpha), y: by + (bvy * alpha), vx: nb.vx, vy: nb.vy }));
    } else if(nb){
      // appeared recently
      balls.push(Object.assign({}, nb));
    } else if(pb){
      // disappeared -> keep previous (maybe pocketed)
      balls.push(Object.assign({}, pb));
    }
  });
  return { balls, pocketed: latest.pocketed||[], players: latest.players||[], turn: latest.turn, ballInHand: latest.ballInHand, lastEvent: latest.lastEvent };
}

let lastPocketedCount = 0;
function handleLastEvent(state){
  if(!state) return;
  const count = (state.pocketed||[]).length;
  if(count > lastPocketedCount){
    // animate pocketed swatch pulse on new pockets
    // we'll add a CSS class to newest ones briefly
    setTimeout(()=> {
      const items = pocketedEl.children;
      if(items && items.length) {
        const last = items[items.length-1];
        if(last) { last.classList.add('pulse'); setTimeout(()=> last.classList.remove('pulse'), 700); }
      }
    }, 40);
  }
  lastPocketedCount = count;
}

/* UI render */
function renderPlayersAndPocketed(state){
  if(!state) return;
  playersEl.innerHTML = '';
  (state.players||[]).forEach(p => {
    const d = document.createElement('div'); d.className='player' + (state.turn === p.id ? ' current' : '');
    d.innerHTML = `<div>${escapeHtml(p.name||p.id)}</div><div class="small">${p.group||''}</div>`;
    playersEl.appendChild(d);
  });

  pocketedEl.innerHTML = '';
  (state.pocketed||[]).slice(-18).forEach(n => {
    if(n === 0) return;
    const el = document.createElement('div'); el.className='pocket-swatch';
    if(n >= 9){
      el.style.background = '#fff'; el.style.border = '2px solid #222';
      const inner = document.createElement('div'); inner.className='inner'; inner.style.background = PALETTE[n] || '#ddd';
      el.appendChild(inner);
    } else {
      el.style.background = PALETTE[n] || '#ddd'; el.style.border = '2px solid #222';
    }
    pocketedEl.appendChild(el);
  });

  if(state.ballInHand) noticeEl.textContent = 'Ball-in-hand: place the cue';
  else {
    const moving = (state.balls||[]).some(b=>Math.hypot(b.vx||0,b.vy||0) > 0.03);
    if(moving) noticeEl.textContent = 'Balls moving...';
    else if(state.turn === myId) noticeEl.textContent = 'Your turn — drag to aim';
    else { const p = (state.players||[]).find(pp=>pp.id === state.turn); noticeEl.textContent = p ? `Waiting for ${p.name}` : 'Waiting...'; }
  }
}
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* draw helpers: draw proper stripe band with clipping and animated rotation */
function drawBall(b, t){
  const x = b.x, y = b.y, r = b.r || 10;
  // soft shadow
  ctx.beginPath(); ctx.ellipse(x+4, y+6, r*0.95, r*0.6, 0, 0, Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fill();

  if(b.pattern === 'stripe' || b.stripe){
    // draw base (striped balls usually have a white base with colored stripe)
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill();
    // stripe band
    const stripeW = (b.stripeWidth || Math.round(r * 1.1));
    const baseAngle = (b.stripeAngle || 0);
    const rot = baseAngle + (t * 0.2); // subtle rotation animation
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(rot);
    // clip to circle
    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.clip();
    // stripe rect (wide enough to cover)
    ctx.beginPath(); ctx.rect(-r*2, -stripeW/2, r*4, stripeW);
    ctx.fillStyle = b.color || '#ddd';
    ctx.fill();
    ctx.restore();

    // small shading / highlight
    ctx.beginPath();
    ctx.arc(x - r*0.35, y - r*0.55, r*0.28, 0, Math.PI*2);
    ctx.fillStyle='rgba(255,255,255,0.7)';
    ctx.fill();

    // outline
    ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();
  } else {
    // solid ball with radial gradient
    const grad = ctx.createRadialGradient(x - r*0.25, y - r*0.4, r*0.08, x, y, r*1.15);
    grad.addColorStop(0,'#fff'); grad.addColorStop(0.14,b.color||'#ddd'); grad.addColorStop(1,'#060708');
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=grad; ctx.fill();
    ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.stroke();
    ctx.beginPath(); ctx.ellipse(x - r*0.33, y - r*0.52, r*0.33, r*0.5, -0.55, 0, Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.6)'; ctx.fill();
  }

  // number badge
  if(typeof b.num === 'number' && b.num !== 0){
    ctx.beginPath(); ctx.arc(x, y, Math.max(6, r*0.56), 0, Math.PI*2); ctx.fillStyle = 'rgba(0,0,0,0.08)'; ctx.fill();
    ctx.fillStyle = '#000'; ctx.font = `${Math.max(8, Math.round(r*0.6))}px Inter, system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(String(b.num), x, y);
  }
}

/* table draw */
function drawTable(state, t){
  // felt background
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,'#0b3c22'); g.addColorStop(1,'#0c4a2b'); ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

  // pockets
  const pockets = [{x:0,y:0},{x:400,y:0},{x:800,y:0},{x:0,y:400},{x:400,y:400},{x:800,y:400}];
  for(const p of pockets){
    ctx.beginPath(); ctx.arc(p.x, p.y, POCKET_RADIUS, 0, Math.PI*2); ctx.fillStyle = '#000'; ctx.fill();
  }

  // balls
  const balls = state && state.balls ? state.balls.slice().sort((a,b)=>a.y-b.y) : [];
  for(const b of balls) drawBall(b, t);

  // draw aiming prediction if dragging
  if(dragging && dragging.pred && dragging.pred.length){
    ctx.beginPath(); ctx.setLineDash([8,7]); ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.85)';
    ctx.moveTo(dragging.cx, dragging.cy);
    for(const p of dragging.pred) ctx.lineTo(p.x, p.y);
    ctx.stroke(); ctx.setLineDash([]);
  }
}

/* main loop */
let lastFrame = performance.now();
function loop(now){
  const dt = (now - lastFrame)/1000;
  lastFrame = now;
  const state = interpolatedState();
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawTable(state, now/1000);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* periodic requests + keepalive */
setInterval(()=>{ if(ws && ws.readyState===1) ws.send(JSON.stringify({ t:'request_state' })); }, 1200);

/* small utilities */
function findBallById(state, id){ return (state && state.balls || []).find(b=>b.id===id); }

/* initial draw filler message */
ctx.fillStyle = '#9aa0a6'; ctx.font = '14px Inter, system-ui'; ctx.textAlign='center'; ctx.fillText('Connect or create a room to play', canvas.width/2, canvas.height/2);

/* safe escape for display */
function safe(s){ return String(s || ''); }
</script>
</body>
</html>
