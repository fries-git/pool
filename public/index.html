<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Pool â€” prediction & fixes</title>
<style>
body{margin:0;font-family:system-ui;background:#0f1113;color:#eee}
#top{padding:12px;display:flex;gap:8px;align-items:center}
canvas{display:block;margin:12px auto;background:#01361f;border-radius:8px}
#notice{padding:8px;color:#9aa0a6;text-align:center}
#status{margin-left:10px}
</style>
</head>
<body>
<div id="top">
  <input id="username" placeholder="username" />
  <button id="create">Create</button>
  <input id="room" placeholder="ROOM" />
  <button id="join">Join</button>
  <span id="status">disconnected</span>
</div>
<canvas id="table" width="800" height="400"></canvas>
<div id="notice">Not in a room</div>

<script>
const canvas = document.getElementById('table');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');
const noticeEl = document.getElementById('notice');

let ws = null;
let myId = null;
let lastServerState = null;
let prevServerState = null;
let interpolationStart = 0;
let interpolationDuration = 100;

function connect() {
  if (ws && (ws.readyState === 1 || ws.readyState === 0)) return;
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  ws = new WebSocket(proto + '://' + location.host);
  ws.onopen = () => statusEl.textContent = 'connected';
  ws.onclose = () => statusEl.textContent = 'disconnected';
  ws.onmessage = ev => {
    const m = JSON.parse(ev.data);
    if (m.t === 'joined') { myId = m.id; statusEl.textContent = 'in room ' + m.code; noticeEl.textContent = 'In room ' + m.code; }
    else if (m.t === 'state') { prevServerState = lastServerState; lastServerState = m; interpolationStart = Date.now(); interpolationDuration = 1000/20*0.95; }
    else if (m.t === 'shoot_rejected') { noticeEl.textContent = 'Shot rejected: ' + (m.reason || 'unknown'); setTimeout(()=> noticeEl.textContent = '', 2000); }
    else if (m.t === 'place_rejected') { noticeEl.textContent = 'Place rejected: ' + (m.reason || ''); setTimeout(()=> noticeEl.textContent = '', 2000); }
    else if (m.t === 'chat') { console.log('chat', m.from, m.msg); }
    else if (m.t === 'error') { noticeEl.textContent = 'Error: ' + (m.msg || ''); setTimeout(()=> noticeEl.textContent = '', 3000); }
  };
}

document.getElementById('create').onclick = () => {
  const name = (document.getElementById('username').value || 'Host').trim();
  connect();
  if (ws.readyState === 1) ws.send(JSON.stringify({ t:'create', name }));
  else ws.addEventListener('open', ()=> ws.send(JSON.stringify({ t:'create', name })), { once: true });
};
document.getElementById('join').onclick = () => {
  const name = (document.getElementById('username').value || 'Player').trim();
  const code = (document.getElementById('room').value || '').trim().toUpperCase();
  if (!code) return;
  connect();
  if (ws.readyState === 1) ws.send(JSON.stringify({ t:'join', code, name }));
  else ws.addEventListener('open', ()=> ws.send(JSON.stringify({ t:'join', code, name })), { once: true });
};

/* interpolation */
function getLatestState() {
  if (!lastServerState) return null;
  if (!prevServerState) return lastServerState.state;
  const a = prevServerState.state, b = lastServerState.state;
  const now = Date.now();
  const alpha = Math.min(1, Math.max(0, (now - (lastServerState.serverTime || now) + interpolationDuration) / interpolationDuration));
  const mapA = new Map((a.balls||[]).map(x=>[x.id,x]));
  const outBalls = [];
  for (const be of (b.balls||[])) {
    const ae = mapA.get(be.id);
    if (!ae) { outBalls.push(be); continue; }
    outBalls.push(Object.assign({}, be, { x: ae.x + (be.x - ae.x) * alpha, y: ae.y + (be.y - ae.y) * alpha, vx: ae.vx + (be.vx - ae.vx) * alpha, vy: ae.vy + (be.vy - ae.vy) * alpha }));
  }
  return Object.assign({}, b, { balls: outBalls });
}

/* helper: authoritative stop check (use lastServerState not interpolated) */
function canShootAuthoritative() {
  if (!lastServerState) return false;
  const s = lastServerState.state;
  if (!s.turn || s.turn !== myId) return false;
  if (s.ballInHand) return false;
  // check server-side velocities
  const moving = (s.balls||[]).some(b => Math.hypot(b.vx||0, b.vy||0) > 0.03);
  return !moving;
}

/* prediction line (simple raytrace with wall bounces, no ball collisions) */
function computePrediction(cx, cy, angle, power, maxSegments = 6) {
  const segments = [];
  let x = cx, y = cy;
  let vx = Math.cos(angle) * power * 14;
  let vy = Math.sin(angle) * power * 14;
  const STEP = 6;
  const TABLE_W = 800, TABLE_H = 400;
  const POCKETS = [{x:0,y:0},{x:400,y:0},{x:800,y:0},{x:0,y:400},{x:400,y:400},{x:800,y:400}];
  const POCKET_RADIUS = 28;
  for (let seg = 0; seg < maxSegments; seg++) {
    let hit = false;
    for (let t = 0; t < 200; t++) {
      const nx = x + vx * (STEP/60);
      const ny = y + vy * (STEP/60);
      // check pocket
      for (const p of POCKETS) {
        const d = Math.hypot(nx - p.x, ny - p.y);
        if (d <= POCKET_RADIUS + 6) {
          segments.push({ x: nx, y: ny, pocket: true });
          hit = true; break;
        }
      }
      if (hit) break;
      // wall reflect
      if (nx - 10 < 0) { vx = -vx; x = 10; }
      else if (nx + 10 > TABLE_W) { vx = -vx; x = TABLE_W - 10; }
      else x = nx;
      if (ny - 10 < 0) { vy = -vy; y = 10; }
      else if (ny + 10 > TABLE_H) { vy = -vy; y = TABLE_H - 10; }
      else y = ny;
    }
    segments.push({ x, y, pocket: false });
    if (hit) break;
  }
  return segments;
}

/* input/aiming */
let dragging = null;
canvas.addEventListener('mousedown', e => {
  const state = lastServerState && lastServerState.state;
  if (!state) return;
  if (!state.turn || state.turn !== myId) { noticeEl.textContent = 'Not your turn'; setTimeout(()=> noticeEl.textContent='', 1200); return; }
  if (state.ballInHand) {
    const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    if (ws && ws.readyState === 1) ws.send(JSON.stringify({ t:'place_cue', x: mx, y: my }));
    return;
  }
  // use authoritative check
  const moving = (state.balls||[]).some(b => Math.hypot(b.vx||0, b.vy||0) > 0.03);
  if (moving) { noticeEl.textContent = 'Balls still moving'; setTimeout(()=> noticeEl.textContent='', 1200); return; }
  const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const cue = state.balls.find(b => b.id === 'cue'); if (!cue) return;
  dragging = { cx: cue.x, cy: cue.y, mx, my, pred: null };
});
canvas.addEventListener('mousemove', e => {
  if (!dragging) return;
  const rect = canvas.getBoundingClientRect();
  dragging.mx = e.clientX - rect.left; dragging.my = e.clientY - rect.top;
  const dx = dragging.cx - dragging.mx, dy = dragging.cy - dragging.my;
  const dist = Math.hypot(dx, dy); const power = Math.min(1, dist / 180);
  const angle = Math.atan2(dy, dx) + Math.PI;
  dragging.pred = computePrediction(dragging.cx, dragging.cy, angle, power);
});
window.addEventListener('mouseup', e => {
  if (!dragging) return;
  const dx = dragging.cx - dragging.mx, dy = dragging.cy - dragging.my;
  const dist = Math.hypot(dx, dy); const power = Math.min(1, dist / 180);
  const angle = Math.atan2(dy, dx) + Math.PI;
  if (ws && ws.readyState === 1) ws.send(JSON.stringify({ t:'shoot', power, angle }));
  dragging = null;
});

/* rendering */
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // simple felt
  const g = ctx.createLinearGradient(0,0,0,canvas.height); g.addColorStop(0,'#0b3c22'); g.addColorStop(1,'#0c4a2b'); ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
  // pockets
  ctx.fillStyle = '#000'; [[0,0],[400,0],[800,0],[0,400],[400,400],[800,400]].forEach(p=>{ ctx.beginPath(); ctx.arc(p[0],p[1],28,0,Math.PI*2); ctx.fill(); });
  const state = getInterpolatedState() || (lastServerState ? lastServerState.state : null);
  if (state && state.balls) {
    // draw balls
    const sorted = state.balls.slice().sort((a,b)=>a.y - b.y);
    for (const b of sorted) drawBall(b);
    // draw prediction
    if (dragging && dragging.pred) {
      ctx.beginPath(); ctx.setLineDash([6,6]); ctx.lineWidth = 2; ctx.strokeStyle = '#fff';
      ctx.moveTo(dragging.cx, dragging.cy);
      for (const s of dragging.pred) ctx.lineTo(s.x, s.y);
      ctx.stroke(); ctx.setLineDash([]);
    }
    // notice update based on authoritative state
    const auth = lastServerState ? lastServerState.state : null;
    if (auth) {
      if (auth.ballInHand) noticeEl.textContent = 'Ball-in-hand: place cue';
      else {
        const moving = (auth.balls||[]).some(b => Math.hypot(b.vx||0, b.vy||0) > 0.03);
        if (moving) noticeEl.textContent = 'Balls moving...';
        else if (auth.turn === myId) noticeEl.textContent = 'Your turn';
        else { noticeEl.textContent = 'Waiting for other player'; }
      }
    }
  } else {
    ctx.fillStyle = '#ccc'; ctx.fillText('Not in a room', 10, 20);
  }
  requestAnimationFrame(draw);
}

function drawBall(b) {
  const x = b.x, y = b.y, r = b.r || 10;
  // shadow
  ctx.beginPath(); ctx.ellipse(x+3, y+5, r*0.95, r*0.6, 0,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fill();
  // body
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2);
  ctx.fillStyle = b.stripe ? '#fff' : (b.color || '#ddd'); ctx.fill();
  if (b.stripe) { ctx.beginPath(); ctx.arc(x,y,r*0.66,0,Math.PI*2); ctx.fillStyle = b.color || '#ddd'; ctx.fill(); }
  ctx.lineWidth = 1; ctx.strokeStyle = '#222'; ctx.stroke();
  // specular
  ctx.beginPath(); ctx.ellipse(x - r*0.35, y - r*0.55, r*0.35, r*0.55, -0.6, 0, Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.55)'; ctx.fill();
  // number
  if (b.num !== 0) { ctx.fillStyle = b.stripe ? '#000' : '#000'; ctx.font = '10px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(String(b.num), x, y); }
}

/* interpolation helper */
function getInterpolatedState(){
  if (!lastServerState) return null;
  if (!prevServerState) return lastServerState.state;
  const a = prevServerState.state, b = lastServerState.state;
  const now = Date.now();
  const alpha = Math.min(1, Math.max(0, (now - (lastServerState.serverTime || now) + interpolationDuration) / interpolationDuration));
  const mapA = new Map((a.balls||[]).map(x=>[x.id,x]));
  const out = { balls: [] };
  for (const be of (b.balls||[])) {
    const ae = mapA.get(be.id);
    if (!ae) { out.balls.push(be); continue; }
    out.balls.push({ ...be, x: ae.x + (be.x - ae.x) * alpha, y: ae.y + (be.y - ae.y) * alpha, vx: ae.vx + (be.vx - ae.vx) * alpha, vy: ae.vy + (be.vy - ae.vy) * alpha });
  }
  out.players = b.players; out.pocketed = b.pocketed; out.turn = b.turn; out.ballInHand = b.ballInHand; out.lastEvent = b.lastEvent;
  return out;
}

/* polling authoritative state occasionally */
setInterval(()=>{ if (ws && ws.readyState === 1) ws.send(JSON.stringify({ t:'request_state' })); }, 1200);

draw();
</script>
</body>
</html>
